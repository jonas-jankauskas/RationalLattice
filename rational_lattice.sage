"""
    rational_lattice.sage: SAGE code for the class that implements lattices generated by rational vectors in Q^n over Z. Given a collection of m, 1 <= m <= n,  linearly independent vectors S={v_1, v_2, ... v_m} of Q^n, a lattice L spanned by S over Z is the set L = Z*v_1 + ... Z*v_m. It consists of all possible linear combinations c_1*v_1+c_2*v_2 ... c_n*v_m of generating vectors, where the coefficients c_i are integers.
    __author__     = Jonas Jankauskas
    __copyright__  = "Copyright 2022, Jonas Jankauskas, all rights reserved"
    __license__    = "LGPLv3"
    __version__    = "0.1 beta"
    __maintainer__ ="Jonas Jankauskas"
    __email__      = jonas.jankauskas@gmail.com
    __status__     = "In development"
"""
class RationalVectorLattice:
    """
        Class RationalLattice implements basic operations on rational lattices - lattices spanned over Z by the finite collections of vectors v_1, v_2, ..., v_n from Q^d with rational entries. Each such lattice L can be represented by a d x n rational matrix B = [v1, ..., v_n], called spanning matrix, so that L=BZ^n. When columns of B are linearly independent, B is called the basis matrix of L.
        
        Implemented lattice operations:
        - simplification
        - dual L* of L
        - Minkowski sum K+L
        - intersection of K and L
        - integral part of L
    """
#---------------------------------------------------------------------------------------------------------------
    def __init__(self, span_matrix=None):
        """
            Constructs a rational lattice.
            
            Arguments:
            	- span_matrix (optional) - d x n matrix A whose columns span lattice L in Z^d: L=AZ^n. Can be any SAGE matrix with entries that can be type-cast to rational numbers.

            If B is provided, the constructor initializes:
            
            	-- self.bmatrix - d x m,  basis matrix B for the lattice L spanned by the column vectors of A in Z^d, where m<= min(d,n). Columns of B are linearly independent (while A might not be).
            	-- self.intpart - maximal integer sublattice of L.
            
            Return:
            - an object of  RationalLattice class type.
        """
        if span_matrix is not None:
            self.bmatrix = self.simplify(span_matrix)
            self.intpart = self.intsub(base_matrix)
        
        return None
#---------------------------------------------------------------------------------------------------------------
    def dual(self,L):
        """
            Computes the dual lattice L* of L in Z^d.
            
            Arguments:
                L - d x n rational spanning matrix of a lattice.
                
            Return:
                M - d x m basis matrix of a lattice L*, such that L* = MZ^m, m <= min(d, n).
        """
        #when L has more than rows, reduce by adding empty lattice generated by zero column
        auxL = self.simplify(L)
        return auxL*(((auxL.transpose())*auxL).inverse())
#---------------------------------------------------------------------------------------------------------------
    def add(self,K,L):
        """
            Calculates direct Minkowski (direct) sum  KZ^m + LZ^n.
            
            Arguments:
                K, L - d x m and d x n rational spanning matrices of two lattices.
                
            Return:
                M - d x k rational basis matrix such that MZ^k = span(KZ^m, LZ^n), k <= min(d,m,n).
        """
        M = K.augment(L)
        cden = M.denominator()
        N = (cden*M).change_ring(ZZ)
        S,U,V = N.smith_form()
        return U.det()*U.adjugate()*S[:,:S.rank()]/cden
#---------------------------------------------------------------------------------------------------------------
    def intersect2(self,K, L):
        """
            Computes intersection of lattices KZ^m and LZ^n.
            
            Arguments:
                K, L - d x m and d x n rational spanning matrices of two rational lattices.
                
            Return:
                M - d x k rational basis matrix such that MZ^k = (KZ^m intersection with LZ^n), k <= min(d,m,n).
        """
        return self.dual(self.add(self.dual(K),self.dual(L)))

#---------------------------------------------------------------------------------------------------------------
    def intersect(self, K, L):
        """
            Computes intersection of two lattices KZ^d and LZ^n in Q^d. KZ^d must be of full rank d in Q^d, while L might have rank d or less.
            
            Arguments:
                K, L - d x d and d x n rational spanning matrices of two rational lattices in Q^d, with n <=d. K must be of full rank (that is, a lattice basis matrix).
                
            Return:
                M - d x k rational basis matrix such that MZ^k = (KZ^m intersection with LZ^n), k <= min(d,m).
        """
        M = K.inverse()*L
        cden = M.denominator()
        N = (cden*M).change_ring(ZZ)
        S,U,V=N.smith_form()
        dd = [s//gcd(cden,s) for s in S[:,:S.rank()].diagonal()]
        D = diagonal_matrix(dd, sparse=False)
        if D.nrows() < K.nrows():
            D = block_matrix(2,1,[D,zero_matrix(K.nrows()-D.nrows(),D.ncols())])
        return K*U.det()*U.adjugate()*D
        
#---------------------------------------------------------------------------------------------------------------
    def intsub(self, L):
        """
            Calculates Z^d intersect with LZ^n (the maximal integral sublattice of MZ^n).
            
            Arguments:
                L - d x n rational matrix that spans L = LZ^n.
                
            Return:
                M - d x m integer basis matrix of Z^d intersection with LZ^n, m <= min(d, n).
        """
        return self.intersect(identity_matrix(L.nrows()), L)
#---------------------------------------------------------------------------------------------------------------
    def simplify(self, L):
        """
            Reduces spanning matrix of a lattice to a base matrix. Removes unnecessary linearly dependent colums.
            
            Arguments:
                L - d x n spanning matrix of a lattice LZ^n.
                
            Return:
                M - d x m a basis matrix for the lattice L. It is a matrix with m linearly independent columns that satisfies MZ^m=LZ^n, m <= min(d,n).
        """
        cden = L.denominator()
        M = (cden*L).change_ring(ZZ)
        S,U,V = M.smith_form()
        return U.det()*U.adjugate()*S[:,:S.rank()]/cden

#--------------------------------------------------------------------------------------------------------------
class RationalMatrixLattice:
    """
         Class RationalMatrixLattices implements operations of lattices generated by m x n matrices with rational entries, thought as vectors of the space Q^(m x n).
    """
#--------------------------------------------------------------------------------------------------------------
    def __init__(self, matrix_list=None):
        """
            Constructor for the RationalMatrixLattice class.
        """
        self.rvLattice = RationalVectorLattice()
        return None
#--------------------------------------------------------------------------------------------------------------
    def mat2vec(self, M):
        """
            Vectorizes a m x n matrix into vector of dimension mn, column-by-column.
        """
        return vector(M.base_ring(), M.transpose().list())
#--------------------------------------------------------------------------------------------------------------
    def vec2mat(self, vec, nrows):
        """
            Rearranges a vector if dimensions nrows*n into a matrix dimension nrows x n, putting each consequtive block of nrows coordinates into separate column.
        """
        if len(vec) % nrows != 0:
            raise Exception('Number of rows incompatible with vector dimensions!')
        ncols = len(vec)//nrows
        return matrix(vec.base_ring(), ncols, vec).transpose()
               
#--------------------------------------------------------------------------------------------------------------
    def mats2BigMat(self, matrix_list):
        """
            Vectorizes list of m x n matrices by columns into list of mn column-vectors and combines these columns to a big matrix of size mn*len(matrix_list).
        """
        numr = matrix_list[0].nrows()
        numc = matrix_list[0].ncols()

        vecs = []
        
        for mat in matrix_list:
        
            if (mat.nrows() != numr) or (mat.ncols() != numc):
                raise Exception('Matrices from matrix_list are of different dimenions!')    
            vecs.append(self.mat2vec(mat))

        big_matrix = matrix(vecs).transpose()

        return big_matrix

#--------------------------------------------------------------------------------------------------------------
    def bigMat2mats(self, big_matrix, numr):
        """
           Rearranges column vectors of big_matrix into smaller matrices that have numr rows each.
        """
        if big_matrix.nrows() % numr != 0:
            raise Exception("No. of rows in big_matrix is not divisible by numr!")
            
        return [self.vec2mat(cvec, numr) for cvec in big_matrix.columns()]

#--------------------------------------------------------------------------------------------------------------
    def integralize(self, matrix_list):
        """
            Computes the basis set for the integer matrix lattice spanned by rational matrices provided in the matrix_list over Z.
        """
        bigM = self.mats2BigMat(matrix_list)
        intM = self.rvLattice.intsub(bigM)
        simM =self.rvLattice.simplify(intM)
        intBasis = self.bigMat2mats(simM,matrix_list[0].nrows())
        return intBasis